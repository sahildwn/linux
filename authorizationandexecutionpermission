#!/bin/bash

#1: THIS BASH SCRIPT FIRST ASKS THE USER FOR A VALID USER NAME/ID INORDER TO CHECK WHETHER THE USER NAME/ID PROVIDED IS PRESENT ON THE SYSTEM OR NOT
#2: IF THE USER NAME/ID IS PRESENT, THE SCRIPT THEN ASKS THE USER FOR A VALID GROUP NAME/ID AND AGAIN CHECK WHETHER THE GROUP NAME/ID PROVIDED IS PRESENT ON THE SYSTEM OR NOT
#3: IF THE GROUP NAME/ID IS PRESENT ON THE SYSTEM THEN THE SCRIPT WILL FURTHER CHECK WHETHER THE USERNAME PROVIDED IS A MEMBER OF THE GROUP OR NOT
#4: IF THE USERNAME IS THE MEMBER OF THE GROUP THEN THE SCRIPT WILL ASK THE USER FOR A VALID DIRECTORY AND CHECK IF THE DIRECTORY EXISTS ON THE SYSTEM OR NOT

#       ---NOTE THAT IF ANY OF THE INPUT PROVIDED BY THE USER IS INCORRECT, THE SCRIPT WILL KEEP ON ASKING FOR A VALID INPUT UNTIL IT WILL FIND ONE---

#5: NOW THAT ALL THE THREE INPUTS ARE VALID THE SCRIPT WILL GENERATE A LIST OF FILES FROM THAT DIRECTORY RECURSIVELY
#6: NOW FOR EVERY FILE GENERATED, THE SCRIPT WILL FIRST CHECK WHETHER THE USERNAME PROVIDED BY THE USER MATCHES THE OWNER OF THE FILE OR NOT
#7: IF THERE IS A MATCH, THEN THE SCRIPT WILL FURTHER CHECK WHETHER THE OWNER OF THE FILE HAS EXECUTION PERMISSION OR NOT DENOTED BY "x"
#8: IF THERE IS NOT A MATCH, THE SCRIPT WILL SKIP THIS STEP AND CHECK WHETHER THE GROUPNAME PROVIDED BY THE USER MATCHES THE GROUPNAME OF THE FILE OR NOT
#9: IF THERE IS A MATCH, THEN THE SCRIPT WILL FURTHER CHECK WHETHER THE GROUP OF THE FILE HAS EXECUTION PERMISSION OR NOT DENOTED BY "x"
#10: IF THERE IS NOT A MATCH, THE SCRIPT WILL SKIP THIS STEP AND CHECK WHETHER THE "other" OF THE FILE HAS EXECUTION PERMISSION OR NOT DENOTED BY "x"
#11: NOW THAT THE FILES ARE GENERATED WITH THE PROPER EXECUTION PERMISSION, THE LAST STEP WILL BE TO CLEAN UP THE TEMPORARY DATA CREATED DURING THE PROCESS


#LETTSSAAAGOOOOOOO

#THIS "user()" FUNCTION WILL ASK AN INPUT (USERID OR USERNAME) FROM THE USER AND CHECK WHETHER IT IS PRESENT IN THE "/etc/passwd" DIRECTORY OR NOT

user(){

read -p "please enter a valid username or userid: " usernameid
re='^[0-9]+$'
CHECKNAME=$( getent passwd "$usernameid" | cut -d : -f 1 )

#THIS CONDITION WILL CHECK WHETHER THE INPUT FOR USERID IS A NUMBER OR NOT BY COMPARING IT TO THE "re" VARIABLE
#IF IT IS A NUMBER THEN IT WILL LOOK FOR ITS MATCHING USERNAME IN THE "/etc/passwd" DIRECTORY 

if [[ "$usernameid" =~ $re ]] && [[ "$usernameid" > 0 ]]; then
       	USERNAME=$( getent passwd "$usernameid" | cut -d : -f 1 )

#THIS CONDITION WILL CHECK WHETHER THE "USERNAME" VARIABLE IS EMPTY(MEANING NO MATCH WAS FOUND) OR NOT(MEANS A MATCH WAS FOUND!!) 
       	if [[ -z "$USERNAME" ]]; then
               	echo "the userid is not valid"
		user
       	else
               	echo "userid is valid "
#WHEN THE USERID IS VALID IT WILL CALL THE "groupcall" FUNCTION AND ALONG WITH THAT IT WILL PASS THE VALID USERNAME AS AN ARGUMENT
		groupcall "$CHECKNAME"
       	fi
else

##IF IT IS A NAME THEN IT WILL LOOK FOR ITS MATCHING USERID IN THE SYSTEM
       	USERID=$( id -u "$usernameid" )
	if [[ -z "$USERID" ]]; then
               	echo "the username is not valid"
		user
       	else
               	echo "the username is valid"
		groupcall "$CHECKNAME"
       	fi
fi
}

#THIS "groupcall()" FUNCTION WILL ASK AN INPUT (GROUPID OR GROUPNAME) FROM THE USER AND CHECK WHETHER IT IS PRESENT IN THE "/etc/passwd" DIRECTORY OR NOT

groupcall(){

USR="$1"

read -p "please enter a valid groupname or groupid: " groupnameid

re='^[0-9]+$'
CHECKNAMEGRP=$( getent passwd "$groupnameid" | cut -d : -f 1 )

#THIS CONDITION WILL CHECK WHETHER THE INPUT FOR GROUPID IS A NUMBER OR NOT BY COMPARING IT TO THE "re" VARIABLE
#IF IT IS A NUMBER THEN IT WILL LOOK FOR ITS MATCHING GROUPNAME IN THE "/etc/passwd" DIRECTORY

if [[ "$groupnameid" =~ $re ]] && [[ "$groupnameid" > 0 ]]; then
        GROUPNAME=$( getent passwd "$groupnameid" | cut -d : -f 1 )
        if [[ -z "$GROUPNAME" ]]; then
                echo "the groupid is not valid"
                groupcall
        else
                echo "groupid is valid"

#THIS CONDITION WILL CHECK FOR THE POSSIBLE NUMBER OF GROUPS THE USERNAME BELONGS TO 
#SO IF HE USERNAME DOES BELONG TO A GROUP THE "CHECK" VARIABLE WILL CATCH THE NUMBER OF GROUPS THE USER IS A MEMBER OF
#AND IT WILL CALL THE "" FUNCTION AND ALONG WITH THAT IT WILL PASS THE VALID USERNAME AND GROUPNAME AS THE ARGUMENTS 

		CHECK=$(id -Gn "$CHECKNAME" | grep -c "$CHECKNAMEGRP")
                if [[ "$CHECK" > 0 ]]; then
                        echo "and $USR is a member of group $CHECKNAMEGRP"
                        direct "$USR" "$CHECKNAMEGRP"
                else
                        echo "but $USR is not a member of group $CHECKNAMEGRP"
                fi
		
        fi
else

        GROUPID=$( id -g "$groupnameid" )
        if [[ -z "$GROUPID" ]]; then
                echo "the groupname is not valid"
                groupcall
        else
                echo "the groupname is valid"
        	CHECK=$(id -Gn "$CHECKNAME" | grep -c "$CHECKNAMEGRP")
		if [[ "$CHECK" > 0 ]]; then
                        echo "and $USR is a member of group $CHECKNAMEGRP"
			direct "$USR" "$CHECKNAMEGRP"
                else
                        echo "but $USR is not a member of group $CHECKNAMEGRP"
                fi
	fi
fi

}

direct(){
read -p "please enter a valid directoryname: " directname

US1="$1"

GS1="$2"

if [ -d "$directname" ]; then
	
        echo "directory is present"
	generate "$US1" "$GS1" "$directname"

else
        echo "no such directory"
fi


}


generate(){


dname="$3"
echo "$dname"

i=0
while read line
do
        filenames[$i]="$line"
        (( i++ ))

done< <(ls -R -al "$dname")


for (( i=0; i<=${#filenames[@]}; i++ ))
do
	STARTC=$( echo "${filenames[i]}" | awk '{print $1}' | cut -b 1 )
	
	if [[ "$STARTC" == "-" ]] || [[ "$STARTC" == "d" ]]; then	
        	RESTCOM=$( echo "${filenames[i]}" | awk '{print $3,$4,$5,$6,$7,$8,$9}' )
        	NAMECHECK=$( echo "${filenames[i]}" | awk '{print $3}' )
        	INSIDEFILE=$( echo "${filenames[i]}" | awk '{print $9}' )
        	GROUPCHECK=$( echo "${filenames[i]}" | awk '{print $4}' )
       		ALLPERM=$( echo "${filenames[i]}" | awk '{print $1}' )
        	PERMUSER=$( echo "${filenames[i]}" | awk '{print $1}' | cut -b 4 )
        	PERMGROUP=$( echo "${filenames[i]}" | awk '{print $1}' | cut -b 7 )
        	PERMOTHER=$( echo "${filenames[i]}" | awk '{print $1}' | cut -b 10 )
        	OUTPUT=$( echo " $3/$INSIDEFILE:$ALLPERM $RESTCOM" )

        	if [[ "$1" == "$NAMECHECK" ]]; then

                	if [[ "$PERMUSER" == "x" ]]; then

                        	UVAL=U
                        	UVALEX=Y
                        	echo "$OUTPUT:$UVAL$UVALEX"
			else

                        	UVAL=U
                        	UVALEX=N
                        	echo "$OUTPUT:$UVAL$UVALEX"
                	fi
        	elif [[ "$2" == "$GROUPCHECK" ]]; then

                	if [[ "$PERMGROUP" == "x" ]]; then

                        	GVAL=G
                        	GVALEX=Y
                        	echo "$OUTPUT:$GVAL$GVALEX"
                	else

                        	GVAL=G
                        	GVALEX=N
                        	echo "$OUTPUT:$UVAL$GVALEX"
                	fi
        	elif [[ "$PERMOTHER" == "x" ]]; then
                	OTVALUE=O
                	OTHEREX=Y
			echo "$OUTPUT:$OTVALUE$OTHEREX"
        	else
                	OTVALUE=O
                	OTHEREX=N
                	echo "$OUTPUT:$OTVALUE$OTHEREX"
        	fi
	else
		continue

	fi
done


}


user 

